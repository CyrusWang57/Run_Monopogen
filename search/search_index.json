{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the practice of running Monopogen","text":"<p>Here are the notes documenting the actual process of running Monopogen.</p>"},{"location":"#monopogen","title":"Monopogen","text":"<p>Monopogen is an analysis package for SNV calling from single-cell sequencing, developed and maintained by Ken chen's lab in MDACC.</p> <p> </p> Monopogen workflow <p>Source code of Monopogen can be found at github.com/KChen-lab/Monopogen.</p>"},{"location":"#source-data","title":"Source data","text":"<p>In this note, the data used to run Monopogen is a single cell ATAC sequencing dataset from PBMC by 10X Multiome (PBMC from a Healthy Donor).</p>"},{"location":"#contact","title":"Contact","text":"<p>I am a PhD student in Yanmei Dou's lab at School of Life Sciences, WestLake University. For more details about the note, please feel free to contact me wangchunyi@westlake.edu.cn.  </p>"},{"location":"Debug/","title":"Debug and Refinement","text":""},{"location":"Debug/#dependencies","title":"Dependencies","text":""},{"location":"Debug/#r-environment","title":"R environment","text":"<pre><code>conda install -c conda-forge r-data.table\nconda install -c conda-forge r-e1071\nconda install -c conda-forge r-ggplot2\nconda install -c conda-forge r-r.utils\n</code></pre>"},{"location":"Debug/#other-tools","title":"Other tools","text":"<p>Authors put the binary compatibility tools including <code>samtools, bcftools, beagle</code> in the app folder. If you want to specify tools by yourself, there are several modifications to do. I encountered some errors while running bcftools provided by the author and decided to use module in HPC, so take bcftools as an example here. Line <code>243,423</code> in <code>Monopogen.py</code>; Line <code>210</code> in <code>somatic.py</code></p> <pre><code>bcftools = os.path.abspath(args.app_path) + \"/bcftools\"\n</code></pre> <p>Revised to:</p> <pre><code>bcftools = \"bcftools\" # or path to your bcftools\n</code></pre>"},{"location":"Debug/#sex-chromosomes-is-not-considered-by-default","title":"Sex chromosomes is not considered by default","text":"<p>If you consider the X chromosome, you need to modify the following code.</p>"},{"location":"Debug/#the-way-to-specify-imputation-panel","title":"The way to specify imputation panel","text":"<p>The source code has hardcoded the imputation panel. Line <code>76</code> in <code>Monopogen.py</code></p> <pre><code>imputation_vcf = args.imputation_panel + \"CCDG_14151_B01_GRM_WGS_2020-08-05_\" + record[0] + \".filtered.shapeit2-duohmm-phased.vcf.gz\u201d \n</code></pre> <p>However, the naming convention for the X chromosome's imputation panel in 1KG differs from that of the autosomes. It has been modified to be specified externally.</p> <pre><code>imputation_vcf = args.imputation_panel\n</code></pre> <p>After that, the code for judging the type of <code>args.imputation_panel</code> also needs to be modified. Line <code>92</code> in <code>germline.py</code></p> <pre><code>assert os.path.isdir(args.imputation_panel)\n</code></pre> <p>Revised to:</p> <pre><code>assert os.path.isfile(args.imputation_panel)\n</code></pre>"},{"location":"Debug/#add-x-chromosome-in-multiple-loops","title":"Add X chromosome in multiple loops","text":"<p>Line <code>111,306,318</code> in <code>Monopogen.py</code></p> <pre><code>for chr in range(1, 23):\n    ...\n</code></pre> <p>Revised to:</p> <pre><code>chromosomes = list(range(1, 23)) + ['X']\nfor chr in chromosomes:\n    ...\n</code></pre>"},{"location":"Debug/#modify-source-file","title":"Modify source file","text":"<p>The resource file <code>Monopogen\\resource\\GRCh38.region.10MB.lst</code> and <code>Monopogen\\resource\\GRCh38.region.50MB.lst</code> does not contain the X chromosome also results in the X chromosome not being considered.  Add lines below to <code>GRCh38.region.10MB.lst</code> for example.</p> <pre><code>chrX,2,10000001\nchrX,10000002,20000001\nchrX,20000002,30000001\nchrX,30000002,40000001\nchrX,40000002,50000001\nchrX,50000002,60000001\nchrX,60000002,70000001\nchrX,70000002,80000001\nchrX,80000002,90000001\nchrX,90000002,100000001\nchrX,100000002,110000001\nchrX,110000002,120000001\nchrX,120000002,130000001\nchrX,130000002,140000001\nchrX,140000002,150000001\nchrX,150000002,156040895\n</code></pre>"},{"location":"Debug/#rewrite-code-spliting-bam-by-cell-barcodes","title":"Rewrite code spliting bam by cell barcodes","text":"<p>The original code, when splitting the original BAM file by CB, iterates through the BAM file as many times as there are different CBs, which is very inefficient. Therefore, the code has been rewritten to accomplish the task with just a single iteration through the BAM file.  </p> <p>Substitute Line <code>160-196</code> (<code>def bamSplit</code>) in <code>somatic.py</code> by lines below. <pre><code>def splitBam(cell_barcodes, out_dir, app_path):\n    samtools = app_path + \"/samtools\"\n    output_bam =  out_dir + \"/Bam/merge.filter.targeted.bam\" \n    infile = pysam.AlignmentFile(output_bam, \"rb\")\n    header = infile.header.copy()\n\n    avail_read = 0\n    # create dictionary\n    outfiles = {}\n    for cell in cell_barcodes:\n        tp = infile.header.to_dict()\n\n        if len(tp['RG']) &gt; 1:\n            tp['RG'] = [tp['RG'][0]]\n        tp['RG'][0]['SM'] = cell\n        tp['RG'][0]['ID'] = cell\n\n        outfile = pysam.AlignmentFile(os.path.join(out_dir, \"Bam/split_bam\", cell + \".bam\"), \"wb\", header=tp)\n        outfiles[cell] = outfile\n\n    for read in infile:\n        cell_barcode = robust_get_tag(read, \"CB\")\n        if cell_barcode in outfiles:\n            outfiles[cell_barcode].write(read)\n            avail_read = avail_read + 1\n\n    for outfile in outfiles.values():\n        outfile.close()\n    infile.close()\n\n    for cell in cell_barcodes:\n        cmd = f\"{samtools} index {os.path.join(out_dir, 'Bam/split_bam', cell)}.bam\"\n        os.system(cmd)\n\n    return(avail_read)\n</code></pre></p> <p>Then substitute Line <code>188-200</code> in <code>Monopogen.py</code> by lines below.</p> <pre><code>result = splitBam(cell_lst, args.out, args.app_path)\nif result==0:\n    logger.error(\"No reads detected for cells in \" + args.barcode + \". Please check 1) the input cell barcode file is matched with bam file; 2) the cell barcode name has the same format shown in bam file. For example XX-1!\")\n    logger.error(\"Failed! See instructions above.\")\nexit(1)\n</code></pre> Line <code>188-200</code> in <code>Monopogen.py</code> <pre><code>joblst = []\n\nfor cell in cell_lst:\n        para = \"merge\" + \":\" + cell + \":\" + args.out + \":\" + args.app_path\n        joblst.append(para)\n\nwith Pool(processes=args.nthreads) as pool:\n    result = pool.map(bamSplit, joblst)\n\nif sum(result)==0:\n    logger.error(\"No reads detected for cells in \" + args.barcode + \". Please check 1) the input cell barcode file is matched with bam file; 2) the cell barcode name has the same format shown in bam file. For example XX-1!\")\n    logger.error(\"Failed! See instructions above.\")\n    exit(1)\n</code></pre>"},{"location":"Debug/#other-bugs","title":"Other bugs","text":""},{"location":"Debug/#havent-generate-index-of-vcf-file","title":"Haven't generate index of vcf file.","text":"<p>Add lines above after Line 85 in <code>Monopogen.py</code></p> <pre><code>cmd6 = tabix + \" -p vcf \" + args.out + \"/germline/\" +  jobid + \".gl.vcf.gz; \" + tabix + \" -p vcf \" + out + \"/germline/\" + jobid + \".phased.vcf.gz\"\nf_out.write(cmd6 + \"\\n\")\n</code></pre>"},{"location":"Debug/#separator-is-not-specified-in-read_csv","title":"Separator is not specified in <code>read_csv</code>.","text":"<p>The cell barcode file includes two column: 1.cell barcode; 2.number of reads detected in each cell (separated by tab). Line <code>179-180</code> in <code>Monopogen.py</code></p> <pre><code>cell_clst = pd.read_csv(args.barcode)   \ndf = pd.DataFrame(cell_clst, columns= ['cell','id'])\n</code></pre> <p>Revised to:</p> <pre><code>df = pd.read_csv(args.barcode,sep=\"\\t\",header=0)\n</code></pre>"},{"location":"Debug/#indent-error","title":"Indent error","text":"<p>Line <code>190</code> in <code>Monopogen.py</code></p> <pre><code>for cell in cell_lst:\n                para = \"merge\" + \":\" + str(cell) + \":\" + args.out + \":\" + args.app_path\n                joblst.append(para)\n</code></pre>"},{"location":"Debug/#release-the-limit-on-the-number-of-files-that-can-be-opened-simultaneously","title":"Release the limit on the number of files that can be opened simultaneously","text":"<p>During the joint calling process, the BAM file of each cell is opened. When the number of cells is large, this can exceed the limit of the number of files that can be opened by the Linux system simultaneously. The default value is set to 1048. When the number of your cells exceeds this value, it needs to be adjusted.</p> <pre><code>ulimit -n 2048 # According to your cell barcode count.\n</code></pre>"},{"location":"Debug/#issues-in-ldrefinementr","title":"Issues in LDrefinement.R","text":""},{"location":"Debug/#issues-in-define-snv-pairs","title":"Issues in define SNV pairs","text":"<p>When germline SNV pairs found within the current cell do not surround any de novo SNVs with reads, the process still proceeds to calculations for somatic SNVs. To improve efficiency, an additional layer of judgment is added to the calculations for de novo SNVs.  </p> <p>Line <code>113-129</code> and Line <code>162-177</code> in <code>LDrefinement.R</code> </p> <pre><code>if(length(somaticIndex_i) &gt; 0){\n    # Line 113-129 or Line 162-177\n}\n</code></pre> <p>In the trioloci model, a list of germline SNVs with reads, sorted by coordinates, is first extracted. Then, the nearest downstream germline SNV to the de novo SNV is selected. It is directly assumed that another SNV in the list with a larger coordinate than the first one forms a triolocus with it. However, there is no check to confirm whether the coordinates of this SNV are indeed larger than those of the de novo SNV, which may lead to issues. Add a conditional statement to make process more robust.  </p> <p>Line <code>169</code> in <code>LDrefinement.R</code> <pre><code>if(mat[lower1,i]==mat[upper1,i] &amp;&amp; dis[upper1]&gt;dis[j]){...}\n</code></pre></p>"},{"location":"Debug/#issue-in-the-funtion-weighthedp","title":"Issue in the funtion <code>weighthedP</code>","text":"<p>The function <code>weighthedP</code> is designed to calculate the LD-refinement score of de novo SNVs based on the LD-refinement score of germline SNV pairs. However, it's nonsensical that the bin size for physical distance used here is different from the one used when calculating the LD-refinement score for germline SNV pairs. This needs to be modified.  </p> <pre><code># binsize in calculating germline LD-refinement score (Line 222 in LDrefinement.R)\nbinsize &lt;- c(0, 100, 200, 300, 400, 500, 1000, 2500, 5000, 7500, 10000, 20000, 50000, 100000, 500000, 1000000000000000000)\n# binsize in calculating somatic LD-refinement score (Line 204 in LDrefinement.R)\nbinsize &lt;- c(0, 100, 500, 1000, 2500, 5000, 7500, 10000, 20000, 50000, 100000, 500000, 1000000000000000000)\n</code></pre> <p>Moreover, when indexing the germline LD-refinement score corresponding to the distance of the loci pair, the index is incorrect and should be <code>i-1</code>.  </p> <p>Line <code>213</code> in <code>LDrefinement.R</code> <pre><code>rd_w &lt;- c(rd_w, (1-table$Prob[i])^2)\n</code></pre> Revised to <pre><code>rd_w &lt;- c(rd_w, (1-table$Prob[i-1])^2)\n</code></pre></p>"},{"location":"Debug/#issue-in-adjusting-ld-refinement-score-based-on-their-phasing-information","title":"Issue in adjusting LD refinement score based on their phasing information","text":"<p>When refining the final score for each site, if one of the two-loci and trio-loci LD-refinement scores is missing, the final score is assigned as NA, which is not quite reasonable. It has been modified to be assigned as the existing score among the two. Line <code>346-353</code> in <code>LDrefinement.R</code> </p> <p><pre><code>for(i in seq(1,nrow(dt),1)){\n   if(is.na(a[i])){a[i]&lt;-10}\n   if(is.na(b[i])){b[i]&lt;-10}\n   dt$p_LDrefine[i] &lt;- (a[i]+b[i])*0.5\n   if(dt$p_LDrefine[i]&gt;1){\n    dt$p_LDrefine[i] &lt;- NA\n   }\n}\n</code></pre> Revised to <pre><code>for(i in seq(1,nrow(dt),1)){\n   if(!is.na(a[i]) &amp;  !is.na(b[i])){\n     dt$p_LDrefine[i] &lt;- (a[i] + b[i])/2\n   }\n   if(!is.na(a[i]) &amp;  is.na(b[i])){\n     dt$p_LDrefine[i] &lt;- a[i]\n   }\n   if(is.na(a[i]) &amp;  !is.na(b[i])){\n     dt$p_LDrefine[i] &lt;- b[i]\n   }\n}\n</code></pre></p>"},{"location":"Debug/#paint-germline-ld-refinement-score-plot-of-all-chromosomes-in-a-picture","title":"Paint germline LD refinement score plot of all chromosomes in a picture","text":"<p>Author didn't provide the code painting germline LD refinement score plot of all chromosomes in a picture like below. You can use the script below directly.  </p> <p> </p> Twoloci model from paper <pre><code>library(ggplot2)\n\ndir &lt;- \"path/to/monopogen/somatic/\"\nchr_list &lt;- c(1:22,'X')\nall_data &lt;- data.frame()\n\nfor (i in chr_list) {\n  file_name &lt;- paste0(dir, \"chr\", i, \".germlineTrioLoci_model.csv\")\n  data &lt;- read.csv(file_name, header = TRUE)\n  data$bin[data$bin&gt;5*10^5] &lt;- 50*10^5\n  data$Chromosome &lt;- as.factor(paste(\"Chr\", i, sep=\"\"))\n  all_data &lt;- rbind(all_data, data)\n}\np &lt;- ggplot(all_data, aes(x=bin, y=Prob)) +\n  geom_point(color=\"cadetblue\",size=6)+\n  geom_smooth(color=\"darksalmon\") + scale_x_continuous(trans='log10') +\n  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),\n                     panel.grid.minor = element_blank(), axis.line = element_line(colour = \"black\")) + xlab(\"Physical distance (bp)\") +\n  ylab(\"LD refinement score\") +\n  ylim(0,0.65) +\n  facet_wrap(~ Chromosome, ncol = 6) +\n  labs(title = \"Three-locus LD refinement score on germline SNVs\") +\n  theme_minimal() +\n  theme(\n    strip.text.x = element_text(size = 18, face = \"bold\"),\n    strip.background = element_rect(fill = \"lightgray\", size = 1),\n    plot.title = element_text(hjust = 0.5,size = 18, face = \"bold\"),\n    axis.text.x = element_blank(),\n    axis.text.y = element_blank(),\n    axis.ticks = element_blank(),\n    axis.title.x = element_text(size = 18),\n    axis.title.y = element_text(size = 18),\n    panel.grid.major = element_blank(),\n    panel.grid.minor = element_blank(),\n    panel.spacing = unit(0.5, \"lines\")\n  )\np &lt;- p + theme(\n  axis.ticks = element_line(color = \"black\"),\n  axis.text.y.left = element_text(color = \"black\", size=18),\n  axis.text.x.bottom = element_text(angle = 90, hjust = 1, color = \"black\", size=18)\n)\nprint(p)\nggsave(paste0(dir,\"LDrefinement_germline_trioloci_allchr.pdf\"), plot = p, device = \"pdf\", width = 20, height = 15, dpi = 300)\n</code></pre>"},{"location":"Formula/","title":"Formula","text":""},{"location":"Formula/#methods-in-paper","title":"Methods in paper","text":"<p>The pictures below demonstrates the method of Monopogen described in paper.</p> <p></p> <p></p> <p>In brief, for each custom-defined physical distance bin, Monopogen calculates a linkage proportion for alleles of germline SNV pairs within that distance, and then takes its reciprocal, meaning the closer this value is to 1, the more likely the remaining allele of two SNVs is on the same haplotype within this distance range. Subsequently, this is used as a reference to calculate the phasing probability of the allele of a de novo SNV, which involves calculating the probability that it is on the same haplotype with adjacent germline SNVs for both phasing mode. An average value is taken across all cells, with the higher value indicating the final phasing at the cell population level, and the lower value serving as an indicator for measuring somatic mutations (the higher it is, the more likely it is somatic).</p>"},{"location":"Formula/#code-implementation","title":"Code implementation","text":""},{"location":"Formula/#code","title":"Code","text":"<p>The code below calculates the phasing probability of de novo SNV.  </p> <pre><code>weigthedP &lt;- function(dis=NULL, match=NULL, table=NULL){\n  binsize &lt;- c(0, 100, 200, 300, 400, 500, 1000, 2500, 5000, 7500, 10000, 20000, 50000, 100000, 500000, 1000000000000000000)\n  rd_p &lt;-c()\n  rd_w &lt;-c()\n  for(i in seq(2,length(binsize),1)){\n    index &lt;-which(dis&lt;binsize[i] &amp; dis&gt;=binsize[i-1])\n    if(length(index&gt;0)){\n      pval &lt;- sum(match[index])/length(index)\n      rd_p &lt;- c(rd_p, pval)\n      rd_w &lt;- c(rd_w, (1-table$Prob[i-1])^2)\n    }\n  }\n  p &lt;- 1-sum(rd_p*rd_w)/(sum(rd_w))\n  return(p)\n}\n</code></pre>"},{"location":"Formula/#formula_1","title":"Formula","text":"<p>Abstract the above code into below mathematical formula.  </p> <p>First, for each de novo SNV, the distances to the nearest germline locus are calculated (one locus in the two-loci model and two loci in the trio-loci model). Subsequently, a phasing mode is fitted (<code>0|1</code> or <code>1|0</code>). Set \\(V_{match} = 1\\) if the observed allele matches the nearest germline locus in this phasing mode, and \\(V_{match} = 0\\) otherwise. Consider two distinct sets used in the formulation of analysis. Firstly, let \\(B = \\{b_1,b_2,...,b_i,...,b_n\\}\\)  represent the set of multiple physical distance bins. Each element within this set corresponds to a specific bin. Secondly, for each site, define \\(C = \\{c_1,c_2,...,c_i,...,c_n\\}\\) as the set comprising all cells that exhibit reads at that particular site. For each de novo SNV loucs, calculate  </p> \\[\\begin{align} M_{b_i} &amp;= \\frac {\\sum_{c_i \\in C} (V_{match} | b_i, c_i)} {N_C} \\tag{1} \\\\[10pt] P_{b_i} &amp;= (1 - P_{two_loci} | b_i)^2 \\tag{2} \\\\[10pt] P_{final} &amp;= 1 - \\frac {\\sum_{b_i \\in B} (M_{b_i} * P_{b_i})} {\\sum_{b_i \\in B} P_{b_i}} \\tag{3}  \\end{align}\\] <p>where \\(V_{match} | b_i, c_i\\) denots $V_{match} value in a specific bin \\(b_i\\) and cell \\(c_i\\), \\(N_C\\) denotes the count of cells that have reads in this locus, \\(M_{b_i}\\) denotes the average of \\(V_{match}\\) among cells in the \\(b_i\\), \\(P_{two_loci} | b_i\\) denots two-locus germline LD-refinement score in the \\(b_i\\), \\(P_{b_i}\\) denotes the reciprocal square value of \\(P_{two_loci} | b_i\\) in the \\(b_i\\).  </p> <p>The computation of \\(P_{final}\\) in the trio-locus model follows the same process. If one of the two-loci and trio-loci LD-refinement scores is missing, \\(P_{final}\\) is refined as the existing score among the two.  If both of them exist, \\(P_{final}\\) is refined as the average of two score:  </p> \\[\\begin{align} P_{final} = \\frac {P_{final,two-locus} + P_{final,trio-locus}} {2} \\tag{4}  \\end{align}\\] <p>If \\(P_{final} &lt; 0.5\\), \\(P_{final}\\) is further refined as its reciprocal (implying another way of phasing):  </p> \\[\\begin{align} P_{final} = 1 - P_{final} \\tag{5} \\end{align}\\]"},{"location":"Formula/#discussion","title":"Discussion","text":"<p>The formulas used in the programming implementation are not as straightforward as described in the article. For instance, when one phasing mode of a de novo SNV matches the same haplotype as a nearby germline SNV, the article implies that \\(P_{b_i}\\) should be directly assigned as the germline LD-refinement score. However, in the program, the reciprocal square of this score is taken instead (formula 2). Moreover, while the article states that the \\(P_{final}\\) of two phasing modes should sum to 1, the program\u2019s calculation method suggests that the sum might not equal 1 if both phasing modes\u2019 \\(P_{final}\\) are calculated separately (take \\(V_{match} = V_{match} - 1\\) in formula 1 when calculating another phasing mode). Nonetheless, the program ultimately calculates only one phasing mode's \\(P_{final}\\), taking the reciprocal as the \\(P_{final}\\) for the other mode (formula 5). Despite these discrepancies, the final outcomes seem to align with the article's description. That is, the closer the \\(P_{final}\\) is to 0, the more likely it is that the cell population will follow the current phasing mode. Conversely, the other phasing mode becomes more likely. When the \\(P_{final}\\) or \\(1-P_{final}\\) value approaches 0.5, it indicates that the site is more likely to be a somatic mutation.</p> take chr18 as an example chr pos Ref_allele Alt_allele Depth_total Depth_ref Depth_alt SVM_pos_score LDrefine_twoLoci_score LDrefine_trioLoci_score LDrefine_merged_score BAF_alt chr18 112139 G C 30 7 15 0.955044 nan nan nan 0.681818 chr18 158410 G C 311 179 10 0.060053 0 nan 0 0.0529101 chr18 596992 T G 98 64 9 0.232393 0.467502 0.426227 0.446864 0.123288 chr18 712356 G T 26 14 7 0.245507 0.206008 0 0.103004 0.333333 chr18 2846875 A C 63 27 25 0.986661 0.45058 0.333333 0.391957 0.480769 chr18 2857554 C T 18 8 8 0.993564 0 0 0 0.5 chr18 3262433 G C 20 11 8 0.96917 0.220134 0.176599 0.198367 0.421053 chr18 11981441 C G 114 82 6 0.17834 0.390875 0.364801 0.377838 0.0681818 chr18 12947756 T C 341 284 4 0.932251 0.456537 0.497766 0.477151 0.0138889 chr18 13726683 G A 296 122 101 0.965907 0.0322581 0 0.016129 0.452915 chr18 15409299 G A 12 7 4 0.991091 0.25 0.25 0.25 0.363636 chr18 21111905 C G 327 274 5 0.0377774 0.399851 0.439252 0.419552 0.0179211 chr18 25352261 G A 60 20 19 0.99603 0.492566 0.25 0.371283 0.487179 chr18 50374938 G C 532 215 144 0.817147 0.414215 0.137505 0.27586 0.401114 chr18 54223646 T G 38 14 16 0.999323 0.434783 0.272727 0.353755 0.533333 chr18 63198910 T C 12 5 6 0.954596 0.289829 0 0.144914 0.545455 chr18 76401788 C G 61 27 10 0.595784 0.446991 0.454545 0.450768 0.27027 chr18 77062512 A G 92 36 4 0.963328 0.340844 0.0541977 0.197521 0.1 chr18 79336043 A G 13 5 4 0.895847 0 0 0 0.444444 chr18 79410454 C T 12 5 6 0.999639 0.108491 0.25 0.179245 0.545455 chr18 79684975 T C 34 13 13 0.157345 0.207898 0.324685 0.266291 0.5 chr18 80258333 G T 15 6 4 0.850895 nan nan nan 0.4"},{"location":"Parameters/","title":"Adjustable parameters","text":"<p>The following is a summary of the parameters that can be adjusted.  </p>"},{"location":"Parameters/#external-parameter","title":"External parameter","text":""},{"location":"Parameters/#counts-of-mismatches-in-preprocess","title":"Counts of mismatches in preprocess","text":"<p>Monopogen filtered reads which have 3 mismatches comapared to reference genome by default. <code>parser_preProcess.add_argument('-m', '--max-mismatch', required=False, type=int, default=3, help=\"The maximal alignment mismatch allowed in one reads for variant calling\")</code></p>"},{"location":"Parameters/#reads-count-of-each-cell","title":"reads count of each cell","text":"<p>Monopogen has a parameter for filtering the number of reads per cell, which by default extracts cells that are in the top 80% in terms of read count. When you use cell barcodes that have already been filtered by software like Cell Ranger, you can set this value to 1. <code>parser_somatic.add_argument('-k', '--keep', required= False, default=0.8, help=\"The proportion of reads kept for somatic calling. The cell will be sorted based on reads detected and cells with fewer reads will be removed.\")</code> However, in practice, I found that setting this value to 1 still results in filtering. The reason for this is not clear, but you can directly comment out the code segment that filters cells based on read count.</p> <p>Line <code>182-186</code> in Monopogen.py  <pre><code>args.keep = float(args.keep)\nif args.keep &lt; 1:\n    dis = np.cumsum(df['id'])/np.sum(df['id'])\n    N = sum(dis&gt;(1-args.keep))\n    df = df.iloc[-(N):]\n</code></pre></p>"},{"location":"Parameters/#hardcoded-parameters","title":"Hardcoded parameters","text":"<p>In addition to above external parameters, there are several parameters which may affect the result hardcoded in scripts.  </p>"},{"location":"Parameters/#q-and-q-in-samtools-mpileup","title":"q and Q in samtools mpileup","text":"<p>In samtools mpileup, q and Q represent mapping quality and base quality separatly. In Monopogen, they are set to 20 by default. Line <code>77</code> in <code>monopogen.py</code> and Line <code>213</code> in <code>somatic.py</code> <pre><code>cmd1 = samtools + \" mpileup -b \" + bam_filter + \" -f \"  + reference + \" -r \" +  jobid + \" -q 20 -Q 20 -t DP4 -d 10000 -v \"\n</code></pre></p>"},{"location":"Parameters/#ref-and-alt-dp-of-de-novo-snv","title":"ref and alt dp of de novo SNV","text":"<p>By default, Monopogen filters de novo SNVs based on their read depths for both reference and alternative alleles, with a threshold of 4 set separately for each.</p> <p>Line <code>123</code> in <code>somatic.py</code> <pre><code>if (info_I16[0] + info_I16[1]&gt;=4 and info_I16[2] + info_I16[3]&gt;=4 or (id in info_GT)):\n    ...\n</code></pre></p> What is info_I16? <p>info_I16 is a fileld in vcf file generated by bcftools, which contains 16 fileds. // The fields are: //      depth fwd   .. ref (0) and non-ref (2) //      depth rev   .. ref (1) and non-ref (3) //      baseQ       .. ref (4) and non-ref (6) //      baseQ^2     .. ref (5) and non-ref (7) //      mapQ        .. ref (8) and non-ref (10) //      mapQ^2      .. ref (9) and non-ref (11) //      minDist     .. ref (12) and non-ref (14) //      minDist^2   .. ref (13) and non-ref (15)  </p>"},{"location":"Parameters/#counts-of-snv-pairs","title":"counts of SNV pairs","text":"<p>When calculating the germline LD-refinement score, Monopogen applies a threshold to limit the number of SNV pairs in each physical distance bin. By default, only bins containing over 100 SNV pairs are considered for generating an LD-refinement score. This parameter needs to be adjusted based on the characteristics of the data. When I ran it with scATACseq data, setting this parameter to 100 seemed too strict. Most SNV pairs are concentrated at larger physical distances, and smaller bins may contain only about a dozen SNV pairs, making it impossible to calculate an LD-refinement score. In my experience, adjusting this value to 10 was more appropriate.  </p> <p>Line <code>225 and 234</code> in <code>LDrefinement.R</code> <pre><code>pos &lt;-which(twoloci$germline_dis&lt;binsize[i] &amp; twoloci$germline_dis&gt;=binsize[i-1])\nif(length(pos)&gt;100){...}\n\npos &lt;-which(trioloci$germline_dis&lt;binsize[i] &amp; trioloci$germline_dis&gt;=binsize[i-1])\nif(length(pos)&gt;100){...}\n</code></pre></p>"},{"location":"Results/","title":"Results","text":""},{"location":"Results/#reference","title":"Reference","text":"<p>The following image which demonstrates germline LD-refinement score in sc-DNA-seq and sc-RNA-seq comes from the monopogen article for reference.</p> <p> </p> Germline LD-refinement score in sc-RNA-seq and sc-DNA-seq"},{"location":"Results/#germline-ld-refiment-scores-in-sc-atac-seq","title":"Germline LD-refiment scores in sc-ATAC-seq","text":""},{"location":"Results/#two-loci-model","title":"Two-loci model","text":"Germline LD-refinement score in sc-ATAC-seq (two-loci model)"},{"location":"Results/#trio-loci-model","title":"Trio-loci model","text":"Germline LD-refinement score in sc-ATAC-seq (Trio-loci model)  <p>Generally, the LD-refinement scores and their trends in sc-ATAC-seq are more akin to those observed in sc-RNA-seq rather than in sc-DNA-seq.</p>"},{"location":"Results/#putative-somatic-snv","title":"Putative somatic SNV","text":"<p>Taking chr18 as an example, samtools mpileup yielded a total of <code>54,343</code> sites, of which <code>39,526</code> sites overlapped with 1KG panel. The SNV sites for phasing include those filtered with <code>ref and alt dp &gt; 4</code> and the aforementioned sites overlapping with 1KG, totaling <code>39,586</code>. This means that the candidate de novo SNV sites are very few, only in the tens. The final output of putative somatic SNV sites was only <code>22</code>, which are filtered by SVM model. The improvement needed is how to increase the number of de novo SNVs. The following is the list of putative somatic SNVs of chr18:  </p> take chr18 as an example chr pos Ref_allele Alt_allele Depth_total Depth_ref Depth_alt SVM_pos_score LDrefine_twoLoci_score LDrefine_trioLoci_score LDrefine_merged_score BAF_alt chr18 112139 G C 30 7 15 0.955044 nan nan nan 0.681818 chr18 158410 G C 311 179 10 0.060053 0 nan 0 0.0529101 chr18 596992 T G 98 64 9 0.232393 0.467502 0.426227 0.446864 0.123288 chr18 712356 G T 26 14 7 0.245507 0.206008 0 0.103004 0.333333 chr18 2846875 A C 63 27 25 0.986661 0.45058 0.333333 0.391957 0.480769 chr18 2857554 C T 18 8 8 0.993564 0 0 0 0.5 chr18 3262433 G C 20 11 8 0.96917 0.220134 0.176599 0.198367 0.421053 chr18 11981441 C G 114 82 6 0.17834 0.390875 0.364801 0.377838 0.0681818 chr18 12947756 T C 341 284 4 0.932251 0.456537 0.497766 0.477151 0.0138889 chr18 13726683 G A 296 122 101 0.965907 0.0322581 0 0.016129 0.452915 chr18 15409299 G A 12 7 4 0.991091 0.25 0.25 0.25 0.363636 chr18 21111905 C G 327 274 5 0.0377774 0.399851 0.439252 0.419552 0.0179211 chr18 25352261 G A 60 20 19 0.99603 0.492566 0.25 0.371283 0.487179 chr18 50374938 G C 532 215 144 0.817147 0.414215 0.137505 0.27586 0.401114 chr18 54223646 T G 38 14 16 0.999323 0.434783 0.272727 0.353755 0.533333 chr18 63198910 T C 12 5 6 0.954596 0.289829 0 0.144914 0.545455 chr18 76401788 C G 61 27 10 0.595784 0.446991 0.454545 0.450768 0.27027 chr18 77062512 A G 92 36 4 0.963328 0.340844 0.0541977 0.197521 0.1 chr18 79336043 A G 13 5 4 0.895847 0 0 0 0.444444 chr18 79410454 C T 12 5 6 0.999639 0.108491 0.25 0.179245 0.545455 chr18 79684975 T C 34 13 13 0.157345 0.207898 0.324685 0.266291 0.5 chr18 80258333 G T 15 6 4 0.850895 nan nan nan 0.4"}]}